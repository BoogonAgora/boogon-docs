---
date: '2025-12-23T09:27:41+08:00'
title: '责任交换是我们的开源态度'
authors:
    - name: Boogon
---

> 作者：\(Boogon\)

长期以来，在闭源商业软件开发范式中，开发者的根本目标清晰而确定：**尽早地交付完整的、可运行的软件实体**，供用户立即使用。对于用户而言，他们的期待也与此直接对应：**获得一个“开箱即用”的软件产品**。这个产品被期望是一个封装严密的整体，如同一个做工精致的“黑盒”，用户按下已知的按钮，便可得到预想的结果，服从着某种确定的函数映射。盒子的内部，无论是精巧的齿轮还是流动的代码，都无从也无需被使用者知晓。我们姑且将这种对完整、封闭、即用产品的期待，称为“**黑盒需求**”。这种需求驱动了软件产业数十年的繁荣，它定义了清晰的交付边界与责任归属：开发者负责盒内的一切，确保其完美运行；用户则享有在预设范围内使用它的权利，以及偿付开发者辛苦劳动的报酬。

“黑盒”模式的优越性在于其提供的确定性与服务的完整性。它降低了使用的技术门槛，将复杂性隐藏在友好的界面之下，并承诺了统一的质量标准与技术支持。在这种关系中，用户是纯粹的消费者，而开发团队则是全能的生产者与维护者。一切需求、缺陷与改进，理论上都应回馈至盒子的制造者，等待他们在下一次封装时纳入其中。这构成了一个看似自洽的循环。

然而，开源理念诞生，开源运动兴起，“黑盒需求”的根基开始松动。人们不再满足于软件的功能正确，开始探求软件本身，构建打开“黑盒”的“白盒需求”。开源的本质是代码的可见、可修改、可再分发，它首先在物理意义上打开了那个盒子。但是，打开盒子的行为，在初期往往模糊了责任的边界。“可见”意味着任何缺陷都无处遁形，公众的审视天然带来对完美的更高期待；“可修改”意味着用户不仅报告问题，更可能直接提交修复代码，维护者必须承担起审查、合并与集成这些外来贡献的艰巨责任；“可再分发”则使得任何特定需求的声音都可能被放大，因为每一个未被满足的社区成员，都理论上拥有“分叉”项目的权利。当代码裸露在所有人的目光之下，一种无形的压力也随之产生。来自全球的审视、赞叹，当然也包括批评，都让维护者不再仅仅是为“客户”负责，更仿佛是在为整个技术社区，这个巨大的“客户”的“理想”与“标准”负责。在这种被“凝视”与被“需要”的氛围中，一种“全能维护者”的心态极易萌芽：既然代码是开放的，既然大家寄予厚望，那么我们理应尽力满足每一个合理的期待。

于是，项目往往不自觉地滑向追求“终极黑盒”的陷阱。维护者开始将社区中涌现的、千差万别的需求，视为自己必须纳入盒中的待办事项。他们希望这个打开的盒子，依然能对所有人展现出“开箱即用”的完整性。这背后，是一种**深植于工程师文化的完美主义责任观**，以及对于社区认可与项目成功的渴望。当我们执着于交付一个满足所有用户、所有场景的“终极黑盒”，便会发现这几乎是一项不可能的任务。开源项目的维护资源，通常是非商业化的、有限的，甚至依赖于维护者个人的时间与热忱。他们面对的是一个需求无限碎片化、技术偏好各异、使用场景千差万别的全球性社区。试图为所有人预装一切，试图满足所有人的需求，项目在无止境的特性增生中失去焦点。核心架构为了容纳五花八门的功能而变得臃肿脆弱，配置选项为了迎合各种场景而繁复到令人望而生畏，最终我们背离开源所倡导的自由与灵活精神。想想，我们的需求，何尝不是我们唾弃的“用户想要整个世界”？

突破这一困境，需要一场彻底的理念重构：**从集中的责任承担，转向明确的责任交换**。

这要求我们重新审视开源协作的基石。当物理的“黑盒”被打开，维护者与用户之间那道泾渭分明的墙也应被拆解，代之以一张清晰标注着各自领地的协作地图。核心的转变在于：维护者不再承诺交付一个“完整的、可运行的软件实体”，转而承诺交付一个“可被安全、高效地组装成任何所需实体的核心组件与可靠工具”。换言之，我们将**开箱即用**的责任交还给用户和再开发者，由他们基于自身独特的情境、品味和目标，自主选择、配置与构建；我们将严肃地承担起**保障自主构建成为可能**的责任，这具体体现在三个不可推卸的使命：无条件的的**稳定性**，卓越的**可扩展性**，以及清晰明朗的**扩展指南**。

这不是责任的推诿，而是责任的专业化分工。它的核心在于承认一个基本事实：**最理解业务痛点的，必然是长期深植于业务本身的用户；最理解软件本身的，必然是与软件系统一同成长的核心维护者**。责任交换，正是让两者各展所长。维护者无需成为所有领域的业务专家，只需专注于将平台打造成一块绝对平整、留有标准榫卯的基石；用户无需深谙内核的所有奥妙，却能凭借清晰的图纸，在这块基石上筑起属于自己的大厦。

这一理念的成功，早已被诸多顶级的开源项目所验证。它们并非以“功能齐全”著称，却因其卓越的“可构建性”而统治了各自的领域。

**Linux内核**或许是“责任交换”最极致的范例。内核开发者与维护者从未提供“开箱即用”的操作系统，他们交付的，是一个极度稳定、高效、抽象了硬件差异性的核心。这个核心不会完成编撰报告、制作幻灯片的办公任务，也不会完成蜘蛛纸牌、音乐鉴赏的娱乐活动，它提供的，是无与伦比的模块化支持、硬件标准与驱动模型的坚定承诺以及详尽的内核解读。于是，责任被交换了，Ubuntu和Android这些发行版与系统集成商，承担了构建最终可用系统的责任，他们基于内核，自主选择并打包了桌面环境、应用软件和交互界面，以满足从服务器到手机等截然不同的“开箱即用”需求。

**React**重新定义了前端开发的职责边界。核心团队从未试图打造一个涵盖路由、状态管理、样式方案的全栈框架。他们极尽克制地专注于一项责任：提供一种高效、声明式的 UI 构建方式。他们通过组件化模型和Hooks API奠定了构建的基础，并辅以优秀的文档。至于“如何构建一个完整应用”的责任，则被交换给了社区。于是，Redux、React Router、Styled-components等生态项目蓬勃发展，开发者可以根据项目需要，自主选择并组装这些部件，构建出最适合自己的前端“黑盒”。React的成功，正在于它不做“终极黑盒”，而是成为了最好的“白盒组件库”。

**Kubernetes**作为云原生时代的基石，将责任交换的理念运用到了基础设施的层面。Kubernetes本身不承诺部署一个具体的、可用的电商网站或数据库。它提供的是一个强大的、通用的容器编排“引擎”与一套声明式API。它的责任是保障容器调度的可靠性、系统的可扩展性，并定义了如CRD等强大的扩展机制与相应的解读。而“如何利用这个引擎来运行我的具体服务”的责任，则完全交给了用户和生态。Helm负责打包应用，Istio负责管理服务网格，各种Operator负责管理有状态应用。用户像搭配积木一样，自主构建出符合自身运维需求的、高度定制化的云平台。

我曾经在FastAPI社区中询问过[这样的问题](https://github.com/fastapi/fastapi/discussions/14292)：
> I want to know if there is one command for creating fastapi project like create-vue-app and create-react-app.
>
> I think it may be quite useful if I can just type a command and then get all the basic files and codes.

FastAPI团队是这样回复的：
> There is no one "right" file structure.
>
> You can search for existing FastAPI project templates or create your own.

当然，我的诉求就是典型的“黑盒需求”，这种诉求的本质，是希望框架的维护者能提供一个标准的、完整的、立即可用的项目“黑盒”。我输入一条命令，就得到一个最佳实践配置、基础结构完整的项目，可以立刻开始写业务代码，而无需操心项目结构、构建配置、基础依赖等“琐事”。换言之，我期待一个开箱即用的产品。

而这位合作者，完美的诠释了“责任交换”的理念本身：  
**“没有唯一正确的文件结构”**：不定义和交付一个“终极黑盒”项目模板。  
**将“构建初始项目”的责任交换出去**：你可以搜索现有模板或创建自己的。

他们的责任，是专注于FastAPI核心框架的稳定性、性能、API设计以及优秀的文档。他们确保你用来构建的“积木”（即FastAPI库本身）是高质量的。用户和社区的责任，便是根据自身需求，自主选择或创建项目的初始结构和配置，完成真正的**最终实现**。

所以我们在这里提出**责任交换**理念。

我们正在通过实践和帮助他人实践，探索开源世界中更好的协作方式。在此过程中，我们认识到：

- **可构建性高于完整预设**：我们更看重提供一个坚固、可扩展的核心，使得任何所需的功能都能被安全地添加，而非提供一个包含所有功能的、静态的成品。
- **扩展指南与代码同等重要**：清晰的指南、示例与规范，是用户实现自主构建的许可证。
- **生态的繁荣胜于功能的积累**：我们更致力于让社区能够轻松地生长出丰富的扩展，而非由我们垄断所有功能的实现。
- **赋能用户而非仅仅服务用户**：我们的终极目标是让用户获得解决自己问题的一切保证，而非永远等待我们为他们提供解决方案。

对维护者：
- **设计优先，为扩展而生**：将系统设计为一系列明确定义的接口与契约，将具体实现隐藏其后。插件系统、中间件管道、钩子（Hooks）、以及清晰的API边界，不是事后添加的特性，而是架构的基石。
- **稳定性是最高承诺**：对已发布的公共API与核心行为，变更必须慎之又慎。破坏性变更需要漫长的弃用周期、详尽的迁移指南和透明的沟通。因为用户的自主构建都建立于此，稳定即是信任。
- **文档即产品，教程即蓝图**：将文档视为项目的“用户界面”。它不仅需要准确，更需要具备教学性。提供从“入门”到“精通”的完整路径，应包含从简单示例到高级模式的全套指南。一个优秀的教程胜过千行代码。
- **培育生态，划定边界**：勇敢地对与核心愿景不符的功能请求说“不”，并清晰地指引用户利用扩展机制自行实现或寻找社区方案。维护者的职责是耕耘土壤，而不是种下每一棵树。
- **提供脚手架，而非宫殿**：可以创建项目生成工具，但它应是“可拆解”的脚手架——通过交互式选项让用户选择所需组件（数据库、缓存、身份验证等），生成一个清晰、简洁的起点，并暴露所有配置的入口。它的目的是展示最佳实践的组合方式，而非提供一个无法修改的庞然大物。

对用户与再开发：
- **拥抱建造者身份**：将选用的开源项目视为一套高级乐高套装，而非一个成品模型。准备好阅读其扩展文档，并投入时间学习如何将其组合与改装，以满足你的特有需求。
- **先探索，后请求**：在提出“这个功能能否加入？”之前，先询问“我如何利用现有工具实现它？”。查阅文档、搜索生态，很多问题早已有了基于扩展的解决方案。
- **贡献解决方案，而不仅仅是问题**：利用扩展机制成功解决了某个特定需求时，考虑将你的实现开源。它或许可以帮助成千上万有类似场景的人。你的贡献可以是一个插件、一段详细的配置范例，或是一篇技术博客。这正是在丰富你们共同依赖的生态。
- **理解并尊重核心的专注**：维护者保持核心精简的深意，是为了项目长期的健康和所有人的利益。你的定制化需求，正是生态位存在的价值。

我们交换的并非责任本身，而是创造的可能性。我们放弃了对一个完美但静止的“产品”的幻想，却共同赢得了一个可以无限演进、持续适应、充满生机的“生态系统”。这，或许是开源精神给软件世界，乃至所有协作领域，最深刻的一份礼物：**真正的力量，不在于我们交付了什么，而在于我们使他人能够去创造什么。**